= Building Block View

[role="arc42help"]
****
The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, datas structures, ...) as well as their dependencies (relationships, associations, ...)
****

== Level 1: System Overview

[mermaid]
ifdef::env-github[[source,mermaid]]
....
graph TB
    subgraph SKaiNET["SKaiNET Framework"]
        api["SKaiNET-tensors-api"]
        impl["SKaiNET-tensors"]
        perf["Performance Framework"]
    end
    
    subgraph External["External Systems"]
        apps["AI/ML Applications"]
        hardware["Hardware Platforms"]
        kmp["Kotlin Multiplatform"]
    end
    
    apps -->|"uses"| api
    api -->|"implemented by"| impl
    impl -->|"includes"| perf
    impl -->|"executes on"| hardware
    api -->|"built with"| kmp
    impl -->|"built with"| kmp
....

=== System Decomposition

[options="header",cols="1,3,2"]
|===
| Component | Responsibility | Technology

| SKaiNET-tensors-api
| Defines public interfaces for tensor operations, data types, and compute backends
| Kotlin Multiplatform interfaces

| SKaiNET-tensors
| Reference implementation with CPU backend and performance benchmarking
| Kotlin Multiplatform implementation

| Performance Framework
| Benchmarking, measurement, and performance analysis tools
| Integrated testing framework
|===

== Level 2: API Module Decomposition

[mermaid]
ifdef::env-github[[source,mermaid]]
....
graph TD
    subgraph API["SKaiNET-tensors-api"]
        subgraph CoreTypes["Core Types"]
            dtype["DType"]
            shape["Shape"]
            data["TensorData&lt;T,V&gt;"]
        end
        
        subgraph Operations["Operations"]
            ops["TensorOps&lt;T&gt;"]
            tensor["Tensor&lt;T,V&gt;"]
        end
        
        subgraph Backend["Backend"]
            backend["ComputeBackend&lt;T,V&gt;"]
        end
    end
    
    tensor -.->|extends| data
    tensor -.->|extends| ops
    backend -.->|extends| ops
    tensor -->|uses| dtype
    tensor -->|uses| shape
    data -->|uses| shape
....

=== Core Components Description

==== DType (Data Type)
*Purpose*: Sealed interface defining supported numerical data types.

*Responsibilities*:
* Type-safe representation of tensor element types
* Compile-time type checking for operations
* Platform-specific optimizations

*Key Types*:
* `FP32`: 32-bit floating point
* `FP64`: 64-bit floating point  
* `INT32`: 32-bit integer
* `INT64`: 64-bit integer

==== Shape
*Purpose*: Immutable representation of tensor dimensions.

*Responsibilities*:
* Multi-dimensional array shape definition
* Dimension validation and computation
* Broadcasting compatibility checks

*Key Operations*:
* Dimension access and validation
* Total element count calculation
* Shape compatibility verification

==== Tensor<T, V>
*Purpose*: Primary interface for multi-dimensional arrays.

*Type Parameters*:
* `T : DType`: Compile-time data type
* `V`: Runtime value type (Float, Double, Int, Long)

*Responsibilities*:
* Element access with multi-dimensional indexing
* Integration with TensorData for data management
* Integration with TensorOps for operations

== Level 3: Implementation Module Decomposition

[mermaid]
ifdef::env-github[[source,mermaid]]
....
graph TD
    subgraph IMPL["SKaiNET-tensors"]
        subgraph CPUBackend["CPU Backend"]
            cpu_backend["CpuBackend"]
            cpu_tensor["CpuTensorFP32"]
        end
        
        subgraph Benchmarking["Benchmarking"]
            runner["BenchmarkRunner"]
            suite["TensorBenchmarkSuite"]
            baseline["BaselinePerformanceTest"]
        end
        
        subgraph TestSupport["Test Support"]
            utils["TestUtils"]
        end
    end
    
    subgraph APIDeps["API Dependencies"]
        backend_if["ComputeBackend&lt;FP32,Float&gt;"]
        tensor_if["Tensor&lt;FP32,Float&gt;"]
    end
    
    cpu_backend -.->|implements| backend_if
    cpu_tensor -.->|implements| tensor_if
    cpu_backend -->|creates| cpu_tensor
    suite -->|uses| runner
    baseline -->|uses| suite
    baseline -->|uses| utils
....

=== Implementation Components

==== CpuBackend
*Purpose*: CPU-optimized implementation of ComputeBackend.

*Key Features*:
* Matrix multiplication with O(nÂ³) complexity
* Element-wise operations (add, subtract, multiply, divide)
* Scalar operations with broadcasting
* Memory-efficient array operations

*Performance Characteristics*:
* Optimized for single-threaded CPU execution
* Uses native array operations where possible
* Baseline implementation for performance comparison

==== CpuTensorFP32
*Purpose*: Concrete tensor implementation for 32-bit floating point data.

*Internal Structure*:
```kotlin
class CpuTensorFP32(
    override val shape: Shape,
    internal val data: FloatArray
) : Tensor<FP32, Float>
```

*Key Methods*:
* Factory methods: `zeros()`, `ones()`, `full()`, `fromArray()`
* Element access: `get(vararg indices: Int)`
* Operator overloading for mathematical operations

==== Performance Framework
*Purpose*: Comprehensive benchmarking and performance analysis.

*Components*:
* `BenchmarkRunner`: Core benchmarking execution engine
* `TensorBenchmarkSuite`: Predefined benchmark scenarios  
* `BaselinePerformanceTest`: Automated performance regression testing

*Metrics Collected*:
* Execution time statistics (mean, std dev, percentiles)
* Memory usage patterns
* Performance scaling analysis
* Operation throughput measurements

== Dependencies and Relationships

=== Internal Dependencies
* API module defines contracts, implementation module fulfills them
* Performance framework depends on both API and implementation
* Test utilities support both unit and performance testing

=== External Dependencies
* Kotlin Standard Library (collections, math functions)
* Kotlin Test framework for testing infrastructure
* Platform-specific optimizations (JVM arrays, native BLAS)

=== Design Principles Applied
* *Separation of Concerns*: Clear boundary between API and implementation
* *Open/Closed Principle*: Easy to add new backends without API changes
* *Dependency Inversion*: High-level modules depend on abstractions
* *Single Responsibility*: Each component has focused, well-defined purpose