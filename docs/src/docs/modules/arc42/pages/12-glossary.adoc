= Glossary

[role="arc42help"]
****
The most important domain and technical terms used in this architecture document.
****

== Domain Terms

**AI/ML (Artificial Intelligence/Machine Learning)**::
Computing approaches that enable systems to learn patterns from data and make predictions or decisions. SKaiNET provides the computational foundation for building AI/ML applications.

**Deep Learning Framework**::
Software libraries and tools that provide building blocks for creating, training, and deploying neural networks. Examples include TensorFlow, PyTorch, and SKaiNET.

**Neural Network**::
Computing systems inspired by biological neural networks, composed of interconnected nodes (neurons) that process and transform data through weighted connections.

**Tensor**::
A multi-dimensional array that generalizes scalars (0D), vectors (1D), and matrices (2D) to higher dimensions. The fundamental data structure in machine learning computations.

**Broadcasting**::
A technique for performing operations on tensors with different but compatible shapes by automatically expanding smaller tensors to match larger ones.

**Element-wise Operation**::
Mathematical operations applied to corresponding elements of tensors, such as addition, multiplication, or division between two tensors of the same shape.

**Matrix Multiplication (MatMul)**::
A mathematical operation that combines two matrices to produce a result matrix, where each element is computed as the dot product of corresponding row and column vectors.

== Technical Terms

**Backend**::
The computational engine responsible for executing tensor operations on specific hardware platforms (CPU, GPU, TPU). SKaiNET uses pluggable backends for hardware abstraction.

**BLAS (Basic Linear Algebra Subprograms)**::
Standardized low-level routines for common linear algebra operations. Platform-specific implementations (Intel MKL, OpenBLAS) provide optimized performance.

**Compute Backend**::
In SKaiNET, the `ComputeBackend<D, V>` interface that abstracts tensor operations across different hardware platforms while maintaining consistent API behavior.

**CPU Backend**::
SKaiNET's reference implementation (`CpuBackend`) that executes tensor operations on standard processors using optimized array operations and mathematical libraries.

**Data Type (DType)**::
Sealed interface in SKaiNET defining supported numerical data types (FP32, FP64, INT32, INT64) with compile-time type safety and platform-specific optimizations.

**Generic Type System**::
Kotlin's parameterized types used in SKaiNET for compile-time type safety. Example: `Tensor<T : DType, V>` where `T` constrains data types and `V` represents runtime values.

**JIT (Just-In-Time) Compilation**::
Runtime compilation technique that optimizes code during execution. JVM's HotSpot compiler applies JIT optimizations to frequently executed tensor operations.

**Kotlin Multiplatform**::
Technology enabling shared Kotlin code across multiple platforms (JVM, Native, JavaScript) while allowing platform-specific optimizations and implementations.

**Memory Pool**::
Pre-allocated memory regions used to reduce allocation overhead in high-frequency operations. Particularly important for tensor operations creating many temporary objects.

**Operator Overloading**::
Language feature allowing custom definitions for standard operators (+, -, *, /) on user-defined types. SKaiNET uses this for intuitive mathematical notation.

**Shape**::
Immutable representation of tensor dimensions as a list of integers. Examples: `[3, 4]` for a 3×4 matrix, `[100, 28, 28]` for a batch of 28×28 images.

**SIMD (Single Instruction, Multiple Data)**::
Processor instructions that perform the same operation on multiple data elements simultaneously, enabling vectorized computations for improved performance.

== Architecture Terms

**API (Application Programming Interface)**::
Public interfaces and contracts that define how applications interact with SKaiNET. Separated into `SKaiNET-tensors-api` module for clean abstraction.

**Arc42**::
Template for architecture documentation providing standardized sections for describing software architectures. This document follows Arc42 structure.

**Benchmarking Framework**::
SKaiNET's integrated performance measurement system (`BenchmarkRunner`, `TensorBenchmarkSuite`) for systematic performance analysis and regression detection.

**Building Block**::
Architectural components that can be combined to create larger systems. In SKaiNET: tensors, backends, operations, and performance measurement components.

**Cross-cutting Concerns**::
Architectural aspects that affect multiple components, such as error handling, logging, performance measurement, and memory management.

**GitFlow**::
Branching model used in SKaiNET development with specific branch types: master, develop, feature, release, and hotfix branches for structured release management.

**Pluggable Architecture**::
Design pattern allowing runtime selection and substitution of components. SKaiNET's backend system exemplifies this with hardware-specific implementations.

**Quality Attributes**::
System characteristics like performance, reliability, maintainability, and usability that drive architectural decisions and constraints.

**Service Provider Interface (SPI)**::
Design pattern for enabling service discovery and pluggability. SKaiNET uses SPI concepts for backend registration and selection.

== Platform Terms

**Android Runtime (ART)**::
Android's application runtime that executes Kotlin bytecode. SKaiNET targets ART through Kotlin/JVM compilation for Android applications.

**JavaScript Engine**::
Runtime environment for executing JavaScript code (V8, SpiderMonkey). SKaiNET compiles to JavaScript for browser and Node.js deployment.

**JVM (Java Virtual Machine)**::
Runtime environment executing bytecode from Kotlin/Java compilation. Provides garbage collection, JIT optimization, and extensive ecosystem integration.

**Kotlin/Native**::
Kotlin compilation target producing native binaries without virtual machine overhead. Enables direct hardware access and integration with system libraries.

**Native Binary**::
Compiled executable code specific to target processor architecture, providing optimal performance through direct hardware utilization.

**WebAssembly (WASM)**::
Binary instruction format enabling near-native performance in web browsers. SKaiNET can leverage WASM for performance-critical JavaScript operations.

== Performance Terms

**Asymptotic Complexity**::
Mathematical description of algorithm performance scaling. Matrix multiplication has O(n³) complexity, element-wise operations are O(n).

**Baseline Performance**::
Reference performance measurements against which optimizations are compared. SKaiNET establishes baselines through comprehensive benchmarking.

**Cache Efficiency**::
Algorithm design considering processor cache hierarchy for optimal data access patterns, crucial for large tensor operations.

**Memory Footprint**::
Amount of memory consumed by applications during execution. Important consideration for mobile and resource-constrained deployments.

**Performance Regression**::
Degradation in system performance compared to previous versions. SKaiNET's CI/CD pipeline includes automated regression detection.

**Throughput**::
Number of operations completed per unit time, measured in operations per second (ops/sec) or similar metrics.

== Development Terms

**Continuous Integration/Continuous Deployment (CI/CD)**::
Development practices involving automated building, testing, and deployment. SKaiNET uses CI/CD for quality assurance and release management.

**KDoc**::
Kotlin's documentation format similar to Javadoc, used for API documentation with structured comments and annotations.

**Semantic Versioning (SemVer)**::
Versioning scheme (MAJOR.MINOR.PATCH) providing clear expectations about API changes and backward compatibility.

**Test-Driven Development (TDD)**::
Development methodology writing tests before implementation code. Ensures comprehensive test coverage and validates requirements.

== Abbreviations and Acronyms

**ADR**:: Architecture Decision Record
**API**:: Application Programming Interface  
**CPU**:: Central Processing Unit
**GPU**:: Graphics Processing Unit
**IDE**:: Integrated Development Environment
**JIT**:: Just-In-Time (compilation)
**JVM**:: Java Virtual Machine
**ML**:: Machine Learning
**NPU**:: Neural Processing Unit
**ONNX**:: Open Neural Network Exchange
**SPI**:: Service Provider Interface
**TPU**:: Tensor Processing Unit
**WASM**:: WebAssembly